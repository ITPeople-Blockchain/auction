/******************************************************************
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
******************************************************************/

///////////////////////////////////////////////////////////////////////
// Author : Mohan Venkataraman
// Purpose: Explore the Hyperledger/fabric and understand
// how to write an chain code, application/chain code boundaries
// The code is not the best as it has just hammered out in a day or two
// Feedback and updates are appreciated
///////////////////////////////////////////////////////////////////////

package main

import (
	"bufio"
	"errors"
	"fmt"
	"encoding/json"
	"github.com/hyperledger/fabric/core/chaincode/shim"
        "itpUtils"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"time"
	// "github.com/errorpkg"
)

//////////////////////////////////////////////////////////////////////////////////////////////////
// The recType is a mandatory attribute. The original app was written with a single table
// in mind. The only way to know how to process a record was the 70's style 80 column punch card
// which used a record type field. The array below holds a list of valid record types.
// This could be stored on a blockchain table or an application
//////////////////////////////////////////////////////////////////////////////////////////////////
var recType = []string{"ARTINV", "USER", "BID", "AUCREQ", "POSTTRAN", "OPENAUC", "CLAUC", "XFER"}

//////////////////////////////////////////////////////////////////////////////////////////////////
// The following array holds the list of tables that should be created
// The deploy/init deletes the tables and recreates them every time a deploy is invoked
//////////////////////////////////////////////////////////////////////////////////////////////////
var aucTables = []string{"UserTable", "UserCatTable", "ItemTable", "ItemCatTable", "ItemHistoryTable", "AuctionTable", "AucInitTable", "AucOpenTable", "BidTable", "TransTable"}

///////////////////////////////////////////////////////////////////////////////////////
// This creates a record of the Asset (Inventory)
// Includes Description, title, certificate of authenticity or image whatever..idea is to checkin a image and store it
// in encrypted form
// Example:
// Item { 113869, "Flower Urn on a Patio", "Liz Jardine", "10102007", "Original", "Floral", "Acrylic", "15 x 15 in", "sample_9.png","$600", "My Gallery }
///////////////////////////////////////////////////////////////////////////////////////

type ItemObject struct {
	ItemID         string
	RecType        string
	ItemDesc       string
	ItemDetail     string // Could included details such as who created the Art work if item is a Painting
	ItemDate       string
	ItemType       string
	ItemSubject    string
	ItemMedia      string
	ItemSize       string
	ItemPicFN      string
	ItemImage      []byte // This has to be generated AES encrypted using the file name
	AES_Key        []byte // This is generated by the AES Algorithms
	ItemImageType  string // should be used to regenerate the appropriate image type
	ItemBasePrice  string // Reserve Price at Auction must be greater than this price
	CurrentOwnerID string // This is validated for a user registered record
        TimeStamp      string // This is the time stamp
}

////////////////////////////////////////////////////////////////////////////////
// Has an item entry every time the item changes hands
////////////////////////////////////////////////////////////////////////////////
type ItemLog struct {
	ItemID       string // PRIMARY KEY
	Status       string // SECONDARY KEY - OnAuc, OnSale, NA
	AuctionedBy  string // SECONDARY KEY - Auction House ID if applicable
	RecType      string // ITEMHIS
	ItemDesc     string
	CurrentOwner string
	Date         string // Date when status changed
}

/////////////////////////////////////////////////////////////
// Create Buyer, Seller , Auction House, Authenticator
// Could establish valid UserTypes -
// AH (Auction House)
// TR (Buyer or Seller)
// AP (Appraiser)
// IN (Insurance)
// BK (bank)
// SH (Shipper)
/////////////////////////////////////////////////////////////
type UserObject struct {
	UserID    string
	RecType   string // Type = USER
	Name      string
	UserType  string // Auction House (AH), Bank (BK), Buyer or Seller (TR), Shipper (SH), Appraiser (AP)
	Address   string
	Phone     string
	Email     string
	Bank      string
	AccountNo string
	RoutingNo string
        Timestamp string
}

/////////////////////////////////////////////////////////////////////////////
// Register a request for participating in an auction
// Usually posted by a seller who owns a piece of ITEM
// The Auction house will determine when to open the item for Auction
// The Auction House may conduct an appraisal and genuineness of the item
/////////////////////////////////////////////////////////////////////////////

type AuctionRequest struct {
	AuctionID       string
	RecType         string // AUCREQ
	ItemID          string
	AuctionHouseID  string // ID of the Auction House managing the auction
	SellerID        string // ID Of Seller - to verified against the Item CurrentOwnerId
	RequestDate     string // Date on which Auction Request was filed
	ReservePrice    string // reserver price > previous purchase price
	BuyItNowPrice   string // 0 (Zero) if not applicable else specify price
	Status          string // INIT, OPEN, CLOSED (To be Updated by Trgger Auction)
	OpenDate        string // Date on which auction will occur (To be Updated by Trigger Auction)
	CloseDate       string // Date and time when Auction will close (To be Updated by Trigger Auction)
        TimeStamp       string // The transaction Date and Time
}

/////////////////////////////////////////////////////////////
// POST the transaction after the Auction Completes
// Post an Auction Transaction
// Post an Updated Item Object
// Once an auction request is opened for auctions, a timer is kicked
// off and bids are accepted. When the timer expires, the highest bid
// is selected and converted into a Transaction
// This transaction is a simple view
/////////////////////////////////////////////////////////////

type ItemTransaction struct {
	AuctionID       string
	RecType         string // POSTTRAN
	ItemID          string
	TransType       string // Sale, Buy, Commission
	UserId          string // Buyer or Seller ID
	TransDate       string // Date of Settlement (Buyer or Seller)
	HammerTime      string // Time of hammer strike - SOLD
	HammerPrice     string // Total Settlement price
	Details         string // Details about the Transaction
}

////////////////////////////////////////////////////////////////
//  This is a Bid. Bids are accepted only if an auction is OPEN
////////////////////////////////////////////////////////////////

type Bid struct {
	AuctionID string
	RecType   string // BID
	BidNo     string
	ItemID    string
	BuyerID   string // ID Of Buyer - to be verified against the Item CurrentOwnerId
	BidPrice  string // BidPrice > Previous Bid
	BidTime   string // Time the bid was received
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// A Map that holds TableNames and the number of Keys
// This information is used to dynamically Create, Update
// Replace , and Query the Ledger
// In this model all attributes in a table are strings
// The chain code does both validation
// A dummy key like 2016 in some cases is used for a query to get all rows
//
//              "UserTable":        1, Key: UserID
//              "ItemTable":        1, Key: ItemID
//              "UserCatTable":     3, Key: "2016", UserType, UserID
//              "ItemCatTable":     3, Key: "2016", ItemSubject, ItemID
//              "AuctionTable":     1, Key: AuctionID
//              "AucInitTable":     2, Key: Year, AuctionID
//              "AucOpenTable":     2, Key: Year, AuctionID
//              "TransTable":       2, Key: AuctionID, ItemID
//              "BidTable":         2, Key: AuctionID, BidNo
//              "ItemHistoryTable": 4, Key: ItemID, Status, AuctionHouseID(if applicable),date-time
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

func GetNumberOfKeys(tname string) int {
	TableMap := map[string]int{
		"UserTable":        1,
		"ItemTable":        1,
		"UserCatTable":     3,
		"ItemCatTable":     3,
		"AuctionTable":     1,
		"AucInitTable":     2,
		"AucOpenTable":     2,
		"TransTable":       2,
		"BidTable":         2,
		"ItemHistoryTable": 4,
	}
	return TableMap[tname]
}

//////////////////////////////////////////////////////////////
// Invoke Functions based on Function name
// The function name gets resolved to one of the following calls
// during an invoke
//
//////////////////////////////////////////////////////////////
func InvokeFunction(fname string) func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	InvokeFunc := map[string]func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error){
		"PostItem":           PostItem,
		"PostUser":           PostUser,
		"PostAuctionRequest": PostAuctionRequest,
		"PostTransaction":    PostTransaction,
		"PostBid":            PostBid,
		"OpenAuctionForBids": OpenAuctionForBids,
		"BuyItNow":           BuyItNow,
		"TransferItem":       TransferItem,
		"CloseAuction":       CloseAuction,
		"CloseOpenAuctions":  CloseOpenAuctions,
	}
	return InvokeFunc[fname]
}

//////////////////////////////////////////////////////////////
// Query Functions based on Function name
//
//////////////////////////////////////////////////////////////
func QueryFunction(fname string) func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	QueryFunc := map[string]func(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error){
		"GetItem":               GetItem,
		"GetUser":               GetUser,
		"GetAuctionRequest":     GetAuctionRequest,
		"GetTransaction":        GetTransaction,
		"GetBid":                GetBid,
		"GetLastBid":            GetLastBid,
		"GetHighestBid":         GetHighestBid,
		"GetNoOfBidsReceived":   GetNoOfBidsReceived,
		"GetListOfBids":         GetListOfBids,
		"GetItemLog":            GetItemLog,
		"GetItemListByCat":      GetItemListByCat,
		"GetUserListByCat":      GetUserListByCat,
		"GetListOfInitAucs":     GetListOfInitAucs,
		"GetListOfOpenAucs":     GetListOfOpenAucs,
		"ValidateItemOwnership": ValidateItemOwnership,
	}
	return QueryFunc[fname]
}

//var myLogger = logging.MustGetLogger("auction_trading")

type SimpleChaincode struct {
}
var gopath string
var ccPath string
////////////////////////////////////////////////////////////////////////////////
// Chain Code Kick-off Main function
////////////////////////////////////////////////////////////////////////////////
func main() {

	// maximize CPU usage for maximum performance
	runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println("Starting Item Auction Application chaincode BlueMix ver 21 Dated 2016-07-02 09.45.00: ")

	gopath = os.Getenv("GOPATH")
	ccPath = fmt.Sprintf("%s/src/github.com/hyperledger/fabric/auction/art/artchaincode/", gopath)
	//ccPath = fmt.Sprintf("%s/src/github.com/hyperledger/fabric/examples/chaincode/go/artfun/", gopath)
	// Start the shim -- running the fabric
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Println("Error starting Item Fun Application chaincode: %s", err)
	}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SimpleChaincode - Init Chaincode implementation - The following sequence of transactions can be used to test the Chaincode
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func (t *SimpleChaincode) Init(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// TODO - Include all initialization to be complete before Invoke and Query
	// Uses aucTables to delete tables if they exist and re-create them

	//myLogger.Info("[Trade and Auction Application] Init")
	fmt.Println("[Trade and Auction Application] Init")
	var err error

	for _, val := range aucTables {
		err = stub.DeleteTable(val)
		if err != nil {
			return nil, fmt.Errorf("Init(): DeleteTable of %s  Failed ", val)
		}
		err = itpUtils.InitLedger(stub, val)
		if err != nil {
			return nil, fmt.Errorf("Init(): InitLedger of %s  Failed ", val)
		}
	}

	fmt.Println("Init() Initialization Complete  : ", args)
	return []byte("Init(): Initialization Complete"), nil
}

////////////////////////////////////////////////////////////////
// SimpleChaincode - INVOKE Chaincode implementation
// User Can Invoke
// - Register a user using PostUser
// - Register an item using PostItem
// - The Owner of the item (User) can request that the item be put on auction using PostAuctionRequest
// - The Auction House can request that the auction request be Opened for bids using OpenAuctionForBids
// - One the auction is OPEN, registered buyers (Buyers) can send in bids vis PostBid
// - No bid is accepted when the status of the auction request is INIT or CLOSED
// - Either manually or by OpenAuctionRequest, the auction can be closed using CloseAuction
// - The CloseAuction creates a transaction and invokes PostTransaction
////////////////////////////////////////////////////////////////

func (t *SimpleChaincode) Invoke(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	var err error
	var buff []byte

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Check Type of Transaction and apply business rules
	// before adding record to the block chain
	// In this version, the assumption is that args[1] specifies recType for all defined structs
	// Newer structs - the recType can be positioned anywhere and ChkReqType will check for recType
	// example:
	// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostBid", "Args":["1111", "BID", "1", "1000", "300", "1200"]}'
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ChkReqType(args) == true {

		InvokeRequest := InvokeFunction(function)
		if InvokeRequest != nil {
			buff, err = InvokeRequest(stub, function, args)
		}
	} else {
		fmt.Println("Invoke() Invalid recType : ", args, "\n")
		return nil, errors.New("Invoke() : Invalid recType : " + args[0])
	}

	return buff, err
}

//////////////////////////////////////////////////////////////////////////////////////////
// SimpleChaincode - QUERY Chaincode implementation
// Client Can Query
// Sample Data
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetUser", "Args": ["4000"]}'
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItem", "Args": ["2000"]}'
//////////////////////////////////////////////////////////////////////////////////////////

func (t *SimpleChaincode) Query(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {
	var err error
	var buff []byte
	fmt.Println("ID Extracted and Type = ", args[0])
	fmt.Println("Args supplied : ", args)

	if len(args) < 1 {
		fmt.Println("Query() : Include at least 1 arguments Key ")
		return nil, errors.New("Query() : Expecting Transation type and Key value for query")
	}

	QueryRequest := QueryFunction(function)
	if QueryRequest != nil {
		buff, err = QueryRequest(stub, function, args)
	} else {
		fmt.Println("Query() Invalid function call : ", function)
		return nil, errors.New("Query() : Invalid function call : " + function)
	}

	if err != nil {
		fmt.Println("Query() Object not found : ", args[0])
		return nil, errors.New("Query() : Object not found : " + args[0])
	}
	return buff, err
}

//////////////////////////////////////////////////////////////////////////////////////////
// Retrieve User Information
// example:
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetUser", "Args": ["100"]}'
//
//////////////////////////////////////////////////////////////////////////////////////////
func GetUser(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Object and Display it
	Avalbytes, err := itpUtils.QueryLedger(stub, "UserTable", args)
	if err != nil {
		fmt.Println("GetUser() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("GetUser() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetUser() : Response : Successfull -")
	return Avalbytes, nil
}

/////////////////////////////////////////////////////////////////////////////////////////
// Query callback representing the query of a chaincode
// Retrieve a Item by Item ID
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItem", "Args": ["1000"]}'
/////////////////////////////////////////////////////////////////////////////////////////
func GetItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Objects and Display it
	Avalbytes, err := itpUtils.QueryLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Println("GetItem() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("GetItem() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetItem() : Response : Successfull ")
	return Avalbytes, nil
}

/////////////////////////////////////////////////////////////////////////////////////////
// Validates The Ownership of an Asset using ItemID, OwnerID, and HashKey
//
// ./peer chaincode query -l golang -n mycc -c '{"Function": "ValidateItemOwnership", "Args": ["1000", "100", "tGEBaZuKUBmwTjzNEyd+nr/fPUASuVJAZ1u7gha5fJg="]}'
//
/////////////////////////////////////////////////////////////////////////////////////////
func ValidateItemOwnership(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	if len(args) < 3 {
		fmt.Println("ValidateItemOwnership() : Requires 3 arguments Item#, Owner# and Key ")
		return nil, errors.New("ValidateItemOwnership() : Requires 3 arguments Item#, Owner# and Key")
	}

	// Get the Object Information
	Avalbytes, err := itpUtils.QueryLedger(stub, "ItemTable", []string{args[0]})
	if err != nil {
		fmt.Println("ValidateItemOwnership() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("ValidateItemOwnership() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	myItem, err := JSONtoAR(Avalbytes)
	if err != nil {
		fmt.Println("ValidateItemOwnership() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	myKey := GetKeyValue(Avalbytes, "AES_Key")
	fmt.Println("Key String := ", myKey)

	if myKey != args[2] {
		fmt.Println("ValidateItemOwnership() : Key does not match supplied key ", args[2], " - ", myKey)
		jsonResp := "{\"Error\":\"ValidateItemOwnership() : Key does not match asset owner supplied key  " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if myItem.CurrentOwnerID != args[1] {
		fmt.Println("ValidateItemOwnership() : ValidateItemOwnership() : Owner-Id does not match supplied ID ", args[1])
		jsonResp := "{\"Error\":\"ValidateItemOwnership() : Owner-Id does not match supplied ID " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Print("ValidateItemOwnership() : Response : Successfull - \n")
	return Avalbytes, nil
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Retrieve Auction Information
// This query runs against the AuctionTable
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetAuctionRequest", "Args": ["1111"]}'
// There are two other tables just for query purposes - AucInitTable, AucOpenTable
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetAuctionRequest(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Get the Objects and Display it
	Avalbytes, err := itpUtils.QueryLedger(stub, "AuctionTable", args)
	if err != nil {
		fmt.Println("GetAuctionRequest() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("GetAuctionRequest() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetAuctionRequest() : Response : Successfull - \n")
	return Avalbytes, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Retrieve a Bid based on two keys - AucID, BidNo
// A Bid has two Keys - The Auction Request Number and Bid Number
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetLastBid", "Args": ["1111"], "1"}'
//
///////////////////////////////////////////////////////////////////////////////////////////////////
func GetBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	// Check there are 2 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 2 {
		fmt.Println("GetBid(): Incorrect number of arguments. Expecting 2 ")
		fmt.Println("GetBid(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetBid\", \"Args\": [\"1111\",\"6\"]}'")
		return nil, errors.New("GetBid(): Incorrect number of arguments. Expecting 2 ")
	}

	// Get the Objects and Display it
	Avalbytes, err := itpUtils.QueryLedger(stub, "BidTable", args)
	if err != nil {
		fmt.Println("GetBid() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("GetBid() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetBid() : Response : Successfull -")
	return Avalbytes, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Retrieve Auction Closeout Information. When an Auction closes
// The highest bid is retrieved and converted to a Transaction
//  ./peer chaincode query -l golang -n mycc -c '{"Function": "GetTransaction", "Args": ["1111"]}'
//
///////////////////////////////////////////////////////////////////////////////////////////////////
func GetTransaction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	//var err error

	// Get the Objects and Display it
	Avalbytes, err := itpUtils.QueryLedger(stub, "TransTable", args)
	if Avalbytes == nil {
		fmt.Println("GetTransaction() : Incomplete Query Object ")
		jsonResp := "{\"Error\":\"Incomplete information about the key for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	if err != nil {
		fmt.Println("GetTransaction() : Failed to Query Object ")
		jsonResp := "{\"Error\":\"Failed to get  Object Data for " + args[0] + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("GetTransaction() : Response : Successfull")
	return Avalbytes, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a User Object. The first step is to have users
// registered
// There are different types of users - Traders (TRD), Auction Houses (AH)
// Shippers (SHP), Insurance Companies (INS), Banks (BNK)
// While this version of the chain code does not enforce strict validation
// the business process recomends validating each persona for the service
// they provide or their participation on the auction blockchain, future enhancements will do that
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostUser", "Args":["100", "USER", "Ashley Hart", "TRD",  "Morrisville Parkway, #216, Morrisville, NC 27560", "9198063535", "ashley@itpeople.com", "SUNTRUST", "00017102345", "0234678"]}'
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostUser(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	record, err := CreateUserObject(args[0:]) //
	if err != nil {
		return nil, err
	}
	buff, err := UsertoJSON(record) //

	if err != nil {
		fmt.Println("PostuserObject() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostUser(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = itpUtils.UpdateLedger(stub, "UserTable", keys, buff)
		if err != nil {
			fmt.Println("PostUser() : write error while inserting record")
			return nil, err
		}

		// Post Entry into UserCatTable - i.e. User Category Table
		keys = []string{"2016", args[3], args[0]}
		err = itpUtils.UpdateLedger(stub, "UserCatTable", keys, buff)
		if err != nil {
			fmt.Println("PostUser() : write error while inserting recordinto UserCatTable \n")
			return nil, err
		}
	}

	return buff, err
}

func CreateUserObject(args []string) (UserObject, error) {

	var err error
	var aUser UserObject

	// Check there are 11 Arguments
	if len(args) != 11 {
		fmt.Println("CreateUserObject(): Incorrect number of arguments. Expecting 11 ")
		return aUser, errors.New("CreateUserObject() : Incorrect number of arguments. Expecting 11 ")
	}

	// Validate UserID is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return aUser, errors.New("CreateUserObject() : User ID should be an integer")
	}

	aUser = UserObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]}
	fmt.Println("CreateUserObject() : User Object : ", aUser)

	return aUser, nil
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a master Object of the Item
// Since the Owner Changes hands, a record has to be written for each
// Transaction with the updated Encryption Key of the new owner
// Example
//./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostItem", "Args":["1000", "ARTINV", "Shadows by Asppen", "Asppen Messer", "20140202", "Original", "Landscape" , "Canvas", "15 x 15 in", "sample_7.png","$600", "100", "2016-02-02 03:000:00"]}'
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	itemObject, err := CreateItemObject(args[0:])
	if err != nil {
		fmt.Println("PostItem(): Cannot create item object \n")
		return nil, err
	}

	// Check if the Owner ID specified is registered and valid
	ownerInfo, err := ValidateMember(stub, itemObject.CurrentOwnerID)
	fmt.Println("Owner information  ", ownerInfo, itemObject.CurrentOwnerID)
	if err != nil {
		fmt.Println("PostItem() : Failed Owner information not found for ", itemObject.CurrentOwnerID)
		return nil, err
	}

	// Convert Item Object to JSON
	buff, err := ARtoJSON(itemObject) //
	if err != nil {
		fmt.Println("PostItem() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostItem(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = itpUtils.UpdateLedger(stub, "ItemTable", keys, buff)
		if err != nil {
			fmt.Println("PostItem() : write error while inserting record\n")
			return buff, err
		}

		// Put an entry into the Item History Table
		_, err = PostItemLog(stub, itemObject, "INITIAL", "DEFAULT", args[12])
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return nil, err
		}

		// Post Entry into ItemCatTable - i.e. Item Category Table
		// The first key 2016 is a dummy (band aid) key to extract all values
		keys = []string{"2016", args[6], args[0]}
		err = itpUtils.UpdateLedger(stub, "ItemCatTable", keys, buff)
		if err != nil {
			fmt.Println("PostItem() : Write error while inserting record into ItemCatTable \n")
			return buff, err
		}

	}

	secret_key, _ := json.Marshal(itemObject.AES_Key)
	fmt.Println(string(secret_key))
	return secret_key, nil
}

func CreateItemObject(args []string) (ItemObject, error) {

	var err error
	var myItem ItemObject

	// Check there are 13 Arguments provided as per the the struct - two are computed
	if len(args) != 13 {
		fmt.Println("CreateItemObject(): Incorrect number of arguments. Expecting 13 ")
		return myItem, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 13 ")
	}

	// Validate ItemID is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		fmt.Println("CreateItemObject(): ART ID should be an integer create failed! ")
		return myItem, errors.New("CreateItemObject(): ART ID should be an integer create failed!")
	}

	// Validate Picture File exists based on the name provided
	// Looks for file in current directory of application and must be fixed for other locations

	// Validate Picture File exists based on the name provided
	// Looks for file in current directory of application and must be fixed for other locations
	imagePath := ccPath +args[9];
	if _, err := os.Stat(imagePath); err == nil {
	  fmt.Println(imagePath, "  exists!")
	} else {
	  fmt.Println("CreateItemObject(): Cannot find or load Picture File = %s :  %s\n", imagePath, err)
	  return myItem, errors.New("CreateItemObject(): ART Picture File not found " + imagePath)
	}

	// Get the Item Image and convert it to a byte array
	imagebytes, fileType := itpUtils.ImageToByteArray(imagePath)

	// Generate a new key and encrypt the image

	AES_key, _ := itpUtils.GenAESKey()
	AES_enc := itpUtils.Encrypt(AES_key, imagebytes)

	// Append the AES Key, The Encrypted Image Byte Array and the file type
	myItem = ItemObject{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], AES_enc, AES_key, fileType, args[10], args[11], args[12]}

	fmt.Println("CreateItemObject(): Item Object created: ", myItem.ItemID, myItem.AES_Key)

	// Code to Validate the Item Object)
	// If User presents Crypto Key then key is used to validate the picture that is stored as part of the title
	// TODO

	return myItem, nil
}

///////////////////////////////////////////////////////////////////////////////////
// Since the Owner Changes hands, a record has to be written for each
// Transaction with the updated Encryption Key of the new owner
// This function is internally invoked by PostTransaction and is not a Public API
///////////////////////////////////////////////////////////////////////////////////

func UpdateItemObject(stub *shim.ChaincodeStub, ar []byte, hammerPrice string, buyer string) ([]byte, error) {

	var err error
	myItem, err := JSONtoAR(ar)
	if err != nil {
		fmt.Println("U() : UpdateItemObject() : Failed to create Art Record Object from JSON ")
		return nil, err
	}

	// Insert logic to  re-encrypt image by first fetching the current Key
	CurrentAES_Key := myItem.AES_Key
	// Decrypt Image and Save Image in a file
	image := itpUtils.Decrypt(CurrentAES_Key, myItem.ItemImage)

	// Get a New Key & Encrypt Image with New Key
	myItem.AES_Key, _ = itpUtils.GenAESKey()
	myItem.ItemImage = itpUtils.Encrypt(myItem.AES_Key, image)

	// Update the owner to the Buyer and update price to auction hammer price
	myItem.ItemBasePrice = hammerPrice
	myItem.CurrentOwnerID = buyer

	ar, err = ARtoJSON(myItem)
	keys := []string{myItem.ItemID, myItem.CurrentOwnerID}
	err = itpUtils.ReplaceLedgerEntry(stub, "ItemTable", keys, ar)
	if err != nil {
		fmt.Println("UpdateItemObject() : Failed ReplaceLedgerEntry in ItemTable into Blockchain ")
		return nil, err
	}
	fmt.Println("UpdateItemObject() : ReplaceLedgerEntry in ItemTable successful ")

	// Update entry in Item Category Table as it holds the Item object as wekk
	keys = []string{"2016", myItem.ItemSubject, myItem.ItemID}
	err = itpUtils.ReplaceLedgerEntry(stub, "ItemCatTable", keys, ar)
	if err != nil {
		fmt.Println("UpdateItemObject() : Failed ReplaceLedgerEntry in ItemCategoryTable into Blockchain ")
		return nil, err
	}

	fmt.Println("UpdateItemObject() : ReplaceLedgerEntry in ItemCategoryTable successful ")
	return myItem.AES_Key, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Obtain Asset Details and Validate Item
// Transfer Item to new owner - no change in price  - In the example XFER is the recType
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "TransferItem", "Args": ["1000", "100", "tGEBaZuKUBmwTjzNEyd+nr/fPUASuVJAZ1u7gha5fJg=", "300", "XFER"]}'
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func TransferItem(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	var err error

	if len(args) < 6 {
		fmt.Println("TransferItem() : Requires 6 arguments Item#, Owner#, Key#, newOwnerID#, XFER \n")
		return nil, errors.New("TransferItem() : Requires 6 arguments Item#, Owner#, Key#, newOwnerID#, XFER")
	}

	// Let us make sure that the Item is not on Auction
	err = VerifyIfItemIsOnAuction(stub, args[0])
        if err != nil {
                fmt.Println("TransferItem() : Failed Item is either initiated or opened for Auction ", args[0])
                return nil, err
	}

	// Validate New Owner's ID
	_, err = ValidateMember(stub, args[3])
	if err != nil {
		fmt.Println("TransferItem() : Failed transferee not Registered in Blockchain ", args[3])
		return nil, err
	}

	// Validate Item or Asset Ownership
	ar, err := ValidateItemOwnership(stub, "ValidateItemOwnership", args[:3])
	if err != nil {
		fmt.Println("TransferItem() : ValidateItemOwnership() : Failed to authenticate item or asset ownership")
		return nil, err
	}

	myItem, err := JSONtoAR(ar)
	if err != nil {
		fmt.Println("TransferItem() : Failed to create item Object from JSON ")
		return nil, err
	}

	// Insert logic to  re-encrypt image by first fetching the current Key
	CurrentAES_Key := myItem.AES_Key
	// Decrypt Image and Save Image in a file
	image := itpUtils.Decrypt(CurrentAES_Key, myItem.ItemImage)

	// Get a New Key & Encrypt Image with New Key
	myItem.AES_Key, _ = itpUtils.GenAESKey()
	myItem.ItemImage = itpUtils.Encrypt(myItem.AES_Key, image)

	// Update the owner to the new owner transfered to
	myItem.CurrentOwnerID = args[3]

	ar, err = ARtoJSON(myItem)
	keys := []string{myItem.ItemID, myItem.CurrentOwnerID}
	err = itpUtils.ReplaceLedgerEntry(stub, "ItemTable", keys, ar)
	if err != nil {
		fmt.Println("TransferAsset() : Failed ReplaceLedgerEntry in ItemTable into Blockchain ")
		return nil, err
	}
	fmt.Println("TransferAsset() : ReplaceLedgerEntry in ItemTable successful ")

	// Update entry in Item Category Table as it holds the Item object as well
	keys = []string{"2016", myItem.ItemSubject, myItem.ItemID}
	err = itpUtils.ReplaceLedgerEntry(stub, "ItemCatTable", keys, ar)
	if err != nil {
		fmt.Println("TransferAsset() : Failed ReplaceLedgerEntry in ItemCategoryTable into Blockchain ")
		return nil, err
	}

	_, err = PostItemLog(stub, myItem, "Transfer", args[1], args[5])
	if err != nil {
		fmt.Println("TransferItem() : PostItemLog() write error while inserting record\n")
		return nil, err
	}

	fmt.Println("TransferAsset() : ReplaceLedgerEntry in ItemCategoryTable successful ")
	return myItem.AES_Key, nil
}

////////////////////////////////////////////////////////////////////////////////////
// Validate Item Status - Is it currently on Auction, if so Reject Transfer Request
// This can be written better - will do so if things work
// The function return the Auction ID and the Status = OPEN or INIT
////////////////////////////////////////////////////////////////////////////////////

func VerifyIfItemIsOnAuction(stub *shim.ChaincodeStub, itemID string) (error) {
	
	rows, err := GetListOfOpenAucs(stub, "AucOpenTable", []string{"2016"})
        if err != nil {
                return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. Error retrieving values from AucOpenTable: %s", err)
        }

        tlist := make([]AuctionRequest, len(rows))
        err = json.Unmarshal([]byte(rows), &tlist)
        if err != nil {
                fmt.Println("VerifyIfItemIsOnAuction: Unmarshal failed : ", err)
                return  fmt.Errorf("VerifyIfItemIsOnAuction: operation failed. Error un-marshaling JSON: %s", err)
        }

        for i := 0; i < len(tlist); i++ {
                ar := tlist[i]

                // Compare Auction IDs
                if ar.ItemID == itemID {
                     fmt.Println("VerifyIfItemIsOnAuction() Failed : Ummarshall error")
                     return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. %s", itemID)
                }
        }

        // Now Check if an Auction Has been inititiated
	// If so , it has to be removed from Auction for a Transfer

        rows, err = GetListOfInitAucs(stub, "AucInitTable", []string{"2016"})
        if err != nil {
                return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. Error retrieving values from AucInitTable: %s", err)
        }

        tlist = make([]AuctionRequest, len(rows))
        err = json.Unmarshal([]byte(rows), &tlist)
        if err != nil {
                fmt.Println("VerifyIfItemIsOnAuction() Unmarshal failed : ", err)
                return fmt.Errorf("VerifyIfItemIsOnAuction: operation failed. Error un-marshaling JSON: %s", err)
        }

        for i := 0; i < len(tlist); i++ {
                ar := tlist[i]
                if err != nil {
                        fmt.Println("VerifyIfItemIsOnAuction() Failed : Ummarshall error")
                        return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed. %s", err)
                }

                // Compare Auction IDs
                if ar.ItemID == itemID {
                        return fmt.Errorf("VerifyIfItemIsOnAuction() operation failed." )
                }
        }

        return nil
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// POSTS A LOG ENTRY Every Time the Item is transacted
// Valid Status for ItemLog =  OnAuc, OnSale, NA, INITIAL
// Valid AuctionedBy: This value is set to "DEFAULT" but when it is put on auction Auction House ID is assigned
// PostItemLog IS NOT A PUBLIC API and is invoked every time some event happens in the Item's life
// The currentDateTime must be provided by Client
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostItemLog(stub *shim.ChaincodeStub, item ItemObject, status string, ah string, currentDateTime string) ([]byte, error) {

	iLog := ItemToItemLog(item, currentDateTime)
	iLog.Status = status
	iLog.AuctionedBy = ah

	buff, err := ItemLogtoJSON(iLog)
	if err != nil {
		fmt.Println("PostItemLog() : Failed Cannot create object buffer for write : ", item.ItemID)
		return nil, errors.New("PostItemLog(): Failed Cannot create object buffer for write : " + item.ItemID)
	} else {
		// Update the ledger with the Buffer Data
		keys := []string{iLog.ItemID, iLog.Status, iLog.AuctionedBy, currentDateTime}
		err = itpUtils.UpdateLedger(stub, "ItemHistoryTable", keys, buff)
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return buff, err
		}
	}
	return buff, nil
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create an Auction Request
// The owner of an Item, when ready to put the item on an auction
// will create an auction request  and specify a  auction house.
//
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostAuctionRequest", "Args":["1111", "AUCREQ", "1700", "200", "400", "04012016", "1200", "INIT", "2016-05-20 11:00:00.3 +0000 UTC","2016-05-23 11:00:00.3 +0000 UTC", "2016-05-23 11:00:00.3 +0000 UTC"]}'
//
// The start and end time of the auction are actually assigned when the auction is opened  by OpenAuctionForBids()
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostAuctionRequest(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	ar, err := CreateAuctionRequest(args[0:])
	if err != nil {
		return nil, err
	}

        // Let us make sure that the Item is not on Auction
        err = VerifyIfItemIsOnAuction(stub, ar.ItemID)
        if err != nil {
                fmt.Println("PostAuctionRequest() : Failed Item is either initiated or opened for Auction ", args[0])
                return nil, err
        }


	// Validate Auction House to check it is a registered User
	aucHouse, err := ValidateMember(stub, ar.AuctionHouseID)
	fmt.Println("Auction House information  ", aucHouse, " ID: ", ar.AuctionHouseID)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Auction House not Registered in Blockchain ", ar.AuctionHouseID)
		return nil, err
	}

	// Validate Item record
	itemObject, err := ValidateItemSubmission(stub, ar.ItemID)
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Could not Validate Item Object in Blockchain ", ar.ItemID)
		return itemObject, err
	}

	// Convert AuctionRequest to JSON
	buff, err := AucReqtoJSON(ar) // Converting the auction request struct to []byte array
	if err != nil {
		fmt.Println("PostAuctionRequest() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostAuctionRequest(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		//err = stub.PutState(args[0], buff)
		keys := []string{args[0]}
		err = itpUtils.UpdateLedger(stub, "AuctionTable", keys, buff)
		if err != nil {
			fmt.Println("PostAuctionRequest() : write error while inserting record\n")
			return buff, err
		}

		// Post an Item Log and the Auction House ID is included in the log
		// Recall -- that by default that value is "DEFAULT"
		io, err := JSONtoAR(itemObject)
		_, err = PostItemLog(stub, io, "ReadyForAuc", ar.AuctionHouseID, ar.TimeStamp)
		if err != nil {
			fmt.Println("PostItemLog() : write error while inserting record\n")
			return buff, err
		}

		//An entry is made in the AuctionInitTable that this Item has been placed for Auction
		// The UI can pull all items available for auction and the item can be Opened for accepting bids
		// The 2016 is a dummy key and has notr value other than to get all rows

		keys = []string{"2016", args[0]}
		err = itpUtils.UpdateLedger(stub, "AucInitTable", keys, buff)
		if err != nil {
			fmt.Println("PostAuctionRequest() : write error while inserting record into AucInitTable \n")
			return buff, err
		}

	}

	return buff, err
}

func CreateAuctionRequest(args []string) (AuctionRequest, error) {
	var err error
	var aucReg AuctionRequest

	// Check there are 12 Arguments
	// See example -- The Open and Close Dates are Dummy, and will be set by open auction
	// '{"Function": "PostAuctionRequest", "Args":["1111", "AUCREQ", "1000", "200", "100", "04012016", "1200", "1800",
	//   "INIT", "2016-05-20 11:00:00.3 +0000 UTC","2016-05-23 11:00:00.3 +0000 UTC", "2016-05-23 11:00:00.3 +0000 UTC"]}'
	if len(args) != 12 {
		fmt.Println("CreateAuctionRegistrationObject(): Incorrect number of arguments. Expecting 11 ")
		return aucReg, errors.New("CreateAuctionRegistrationObject() : Incorrect number of arguments. Expecting 11 ")
	}

	// Validate UserID is an integer . I think this redundant and can be avoided

	err = validateID(args[0])
	if err != nil {
		return aucReg, errors.New("CreateAuctionRequest() : User ID should be an integer")
	}

	aucReg = AuctionRequest{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]}
	fmt.Println("CreateAuctionObject() : Auction Registration : ", aucReg)

	return aucReg, nil
}

//////////////////////////////////////////////////////////
// Create an Item Transaction record to process Request
// This is invoked by the CloseAuctionRequest
// 
//
////////////////////////////////////////////////////////////
func PostTransaction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	if function != "PostTransaction" {
		return nil, errors.New("PostTransaction(): Invalid function name. Expecting \"PostTransaction\"")
	}

	ar, err := CreateTransactionRequest(args[0:]) //
	if err != nil {
		return nil, err
	}

	// Validate buyer's ID
	buyer, err := ValidateMember(stub, ar.UserId)
	if err != nil {
		fmt.Println("PostTransaction() : Failed Buyer not Registered in Blockchain ", ar.UserId)
		return nil, err
	}

	fmt.Println("PostTransaction(): Validated Buyer information successfully ", buyer, ar.UserId)

	// Validate Item record
	lastUpdatedItemOBCObject, err := ValidateItemSubmission(stub, ar.ItemID)
	if err != nil {
		fmt.Println("PostTransaction() : Failed Could not Validate Item Object in Blockchain ", ar.ItemID)
		return lastUpdatedItemOBCObject, err
	}
	fmt.Println("PostTransaction() : Validated Item Object in Blockchain successfully", ar.ItemID)

	// Update Item Object with new Owner Key
	newKey, err := UpdateItemObject(stub, lastUpdatedItemOBCObject, ar.HammerPrice, ar.UserId)
	if err != nil {
		fmt.Println("PostTransaction() : Failed to update Item Master Object in Blockchain ", ar.ItemID)
		return nil, err
	} else {
		// Write New Key to file
		fmt.Println("PostTransaction() : New encryption Key is  ", newKey)
	}
	fmt.Println("PostTransaction() : Updated Item Master Object in Blockchain successfully", ar.ItemID)

	// Post an Item Log
	itemObject, err := JSONtoAR(lastUpdatedItemOBCObject)
	if err != nil {
		fmt.Println("PostTransaction() : Conversion error JSON to ItemRecord\n")
		return lastUpdatedItemOBCObject, err
	}

	// A life cycle event is added to say that the Item is no longer on auction
	itemObject.ItemBasePrice = ar.HammerPrice
	itemObject.CurrentOwnerID = ar.UserId

	_, err = PostItemLog(stub, itemObject, "NA", "DEFAULT", args[9])
	if err != nil {
		fmt.Println("PostTransaction() : write error while inserting item log record\n")
		return lastUpdatedItemOBCObject, err
	}

	fmt.Println("PostTransaction() : Inserted item log record successfully", ar.ItemID)

	// Convert Transaction Object to JSON
	buff, err := TrantoJSON(ar) //
	if err != nil {
		fmt.Println("GetObjectBuffer() : Failed to convert Transaction Object to JSON ", args[0])
		return nil, err
	}

	// Update the ledger with the Buffer Data
	keys := []string{args[0], args[3]}
	err = itpUtils.UpdateLedger(stub, "TransTable", keys, buff)
	if err != nil {
		fmt.Println("PostTransaction() : write error while inserting record\n")
		return buff, err
	}

	fmt.Println("PostTransaction() : Posted Transaction Record successfully\n")

	// Returns New Key. To get Transaction Details, run GetTransaction

	secret_key, _ := json.Marshal(newKey)
	fmt.Println(string(secret_key))
	return secret_key, nil

}

func CreateTransactionRequest(args []string) (ItemTransaction, error) {

	var at ItemTransaction

	// Check there are 9 Arguments
	if len(args) != 9 {
		fmt.Println("CreateTransactionRequest(): Incorrect number of arguments. Expecting 9 ")
		return at, errors.New("CreateTransactionRequest() : Incorrect number of arguments. Expecting 9 ")
	}

	at = ItemTransaction{args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]}
	fmt.Println("CreateTransactionRequest() : Transaction Request: ", at)

	return at, nil
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a Bid Object
// Once an Item has been opened for auction, bids can be submitted as long as the auction is "OPEN"
//./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostBid", "Args":["1111", "BID", "1", "1000", "300", "1200"]}'
//./peer chaincode invoke -l golang -n mycc -c '{"Function": "PostBid", "Args":["1111", "BID", "2", "1000", "400", "3000"]}'
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func PostBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	bid, err := CreateBidObject(args[0:]) //
	if err != nil {
		return nil, err
	}

	// Reject the Bid if the Buyer Information Is not Valid or not registered on the Block Chain
	buyerInfo, err := ValidateMember(stub, args[4])
	fmt.Println("Buyer information  ", buyerInfo, "  ", args[4])
	if err != nil {
		fmt.Println("PostBid() : Failed Buyer not registered on the block-chain ", args[4])
		return nil, err
	}

	///////////////////////////////////////
	// Reject Bid if Auction is not "OPEN"
	///////////////////////////////////////
	RBytes, err := GetAuctionRequest(stub, "GetAuctionRequest", []string{args[0]})
	if err != nil {
		fmt.Println("PostBid() : Cannot find Auction record ", args[0])
		return nil, errors.New("PostBid(): Cannot find Auction record : " + args[0])
	}

	aucR, err := JSONtoAucReq(RBytes)
	if err != nil {
		fmt.Println("PostBid() : Cannot UnMarshall Auction record")
		return nil, errors.New("PostBid(): Cannot UnMarshall Auction record: " + args[0])
	}

	if aucR.Status != "OPEN" {
		fmt.Println("PostBid() : Cannot accept Bid as Auction is not OPEN ", args[0])
		return nil, errors.New("PostBid(): Cannot accept Bid as Auction is not OPEN : " + args[0])
	}

	///////////////////////////////////////////////////////////////////
	// Reject Bid if the time bid was received is > Auction Close Time
	///////////////////////////////////////////////////////////////////
        if tCompare(bid.BidTime, aucR.CloseDate) == false {
               fmt.Println("PostBid() Failed : BidTime past the Auction Close Time")
               return nil, fmt.Errorf("PostBid() Failed : BidTime past the Auction Close Time %s, %s", bid.BidTime, aucR.CloseDate)
        }

	//////////////////////////////////////////////////////////////////
	// Reject Bid if Item ID on Bid does not match Item ID on Auction
	//////////////////////////////////////////////////////////////////
        if aucR.ItemID != bid.ItemID {
               fmt.Println("PostBid() Failed : Item ID mismatch on bid. Bid Rejected")
               return nil, errors.New("PostBid() : Item ID mismatch on Bid. Bid Rejected")
        }

	//////////////////////////////////////////////////////////////////////
	// Reject Bid if Bid Price is less than Reserve Price
	// Convert Bid Price and Reserve Price to Integer (TODO - Float)
	//////////////////////////////////////////////////////////////////////
	bp, err := strconv.Atoi(bid.BidPrice)
	if err != nil {
               fmt.Println("PostBid() Failed : Bid price should be an integer")
	       return nil, errors.New("PostBid() : Bid price should be an integer")
	}

	hp, err := strconv.Atoi(aucR.ReservePrice)
	if err != nil {
		return nil, errors.New("PostItem() : Reserve Price should be an integer")
	}

	// Check if Bid Price is > Auction Request Reserve Price
	if bp < hp {
		return nil, errors.New("PostItem() : Bid Price must be greater than Reserve Price")
	}

	////////////////////////////
	// Post or Accept the Bid
	////////////////////////////
	buff, err := BidtoJSON(bid) //

	if err != nil {
		fmt.Println("PostBid() : Failed Cannot create object buffer for write : ", args[1])
		return nil, errors.New("PostBid(): Failed Cannot create object buffer for write : " + args[1])
	} else {
		// Update the ledger with the Buffer Data
		// err = stub.PutState(args[0], buff)
		keys := []string{args[0], args[2]}
		err = itpUtils.UpdateLedger(stub, "BidTable", keys, buff)
		if err != nil {
			fmt.Println("PostBidTable() : write error while inserting record\n")
			return buff, err
		}
	}

	return buff, err
}

func CreateBidObject(args []string) (Bid, error) {
	var err error
	var aBid Bid

	// Check there are 11 Arguments
	// See example
	if len(args) != 7 {
		fmt.Println("CreateBidObject(): Incorrect number of arguments. Expecting 6 ")
		return aBid, errors.New("CreateBidObject() : Incorrect number of arguments. Expecting 6 ")
	}

	// Validate Bid is an integer

	_, err = strconv.Atoi(args[0])
	if err != nil {
		return aBid, errors.New("CreateBidObject() : Bid ID should be an integer")
	}

	_, err = strconv.Atoi(args[2])
	if err != nil {
		return aBid, errors.New("CreateBidObject() : Bid ID should be an integer")
	}

	// bidTime = args[6]  sent by the client
	aBid = Bid{args[0], args[1], args[2], args[3], args[4], args[5], args[6]}
	fmt.Println("CreateBidObject() : Bid Object : ", aBid)

	return aBid, nil
}

//////////////////////////////////////////////////////////
// JSON To args[] - return a map of the JSON string
//////////////////////////////////////////////////////////
func JSONtoArgs(Avalbytes []byte) (map[string]interface{}, error) {

	var data map[string]interface{}

	if err := json.Unmarshal(Avalbytes, &data); err != nil {
		return nil, err
	}

	return data, nil
}

//////////////////////////////////////////////////////////
// Variation of the above - return value from a JSON string
//////////////////////////////////////////////////////////

func GetKeyValue(Avalbytes []byte, key string) string {
	var dat map[string]interface{}
	if err := json.Unmarshal(Avalbytes, &dat); err != nil {
		panic(err)
	}

	val := dat[key].(string)
	return val
}

//////////////////////////////////////////////////////////
// Time and Date Comparison
// tCompare("2016-06-28 18:40:57", "2016-06-27 18:45:39")
//////////////////////////////////////////////////////////
func tCompare(t1 string, t2 string) bool {

        layout := "2006-01-02 15:04:05"
        bidTime, err := time.Parse(layout, t1)
        if err != nil {
               fmt.Println("tCompare() Failed : time Conversion error on t1")
               return false
        }

        aucCloseTime, err := time.Parse(layout, t2)
        if err != nil {
               fmt.Println("tCompare() Failed : time Conversion error on t2")
               return false
        }

	if bidTime.Before(aucCloseTime) {
	   return true
	}
	
	return false
}

//////////////////////////////////////////////////////////
// Converts JSON String to an ART Object
//////////////////////////////////////////////////////////
func JSONtoAR(data []byte) (ItemObject, error) {

	ar := ItemObject{}
	err := json.Unmarshal([]byte(data), &ar)
	if err != nil {
		fmt.Println("Unmarshal failed : ", err)
	}

	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an ART Object to a JSON String
//////////////////////////////////////////////////////////
func ARtoJSON(ar ItemObject) ([]byte, error) {

	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an BID to a JSON String
//////////////////////////////////////////////////////////
func ItemLogtoJSON(item ItemLog) ([]byte, error) {

	ajson, err := json.Marshal(item)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoItemLog(ithis []byte) (ItemLog, error) {

	item := ItemLog{}
	err := json.Unmarshal(ithis, &item)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return item, err
	}
	return item, err
}

//////////////////////////////////////////////////////////
// Converts an Auction Request to a JSON String
//////////////////////////////////////////////////////////
func AucReqtoJSON(ar AuctionRequest) ([]byte, error) {

	ajson, err := json.Marshal(ar)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoAucReq(areq []byte) (AuctionRequest, error) {

	ar := AuctionRequest{}
	err := json.Unmarshal(areq, &ar)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return ar, err
	}
	return ar, err
}

//////////////////////////////////////////////////////////
// Converts an BID to a JSON String
//////////////////////////////////////////////////////////
func BidtoJSON(myHand Bid) ([]byte, error) {

	ajson, err := json.Marshal(myHand)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoBid(areq []byte) (Bid, error) {

	myHand := Bid{}
	err := json.Unmarshal(areq, &myHand)
	if err != nil {
		fmt.Println("JSONtoAucReq error: ", err)
		return myHand, err
	}
	return myHand, err
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func UsertoJSON(user UserObject) ([]byte, error) {

	ajson, err := json.Marshal(user)
	if err != nil {
		fmt.Println("UsertoJSON error: ", err)
		return nil, err
	}
	fmt.Println("UsertoJSON created: ", ajson)
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an User Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoUser(user []byte) (UserObject, error) {

	ur := UserObject{}
	err := json.Unmarshal(user, &ur)
	if err != nil {
		fmt.Println("UsertoJSON error: ", err)
		return ur, err
	}
	fmt.Println("UsertoJSON created: ", ur)
	return ur, err
}

//////////////////////////////////////////////////////////
// Converts an Item Transaction to a JSON String
//////////////////////////////////////////////////////////
func TrantoJSON(at ItemTransaction) ([]byte, error) {

	ajson, err := json.Marshal(at)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return ajson, nil
}

//////////////////////////////////////////////////////////
// Converts an Trans Object to a JSON String
//////////////////////////////////////////////////////////
func JSONtoTran(areq []byte) (ItemTransaction, error) {

	at := ItemTransaction{}
	err := json.Unmarshal(areq, &at)
	if err != nil {
		fmt.Println("JSONtoTran error: ", err)
		return at, err
	}
	return at, err
}

//////////////////////////////////////////////
// Validates an ID for Well Formed
//////////////////////////////////////////////

func validateID(id string) error {
	// Validate UserID is an integer

	_, err := strconv.Atoi(id)
	if err != nil {
		return errors.New("validateID(): User ID should be an integer")
	}
	return nil
}

//////////////////////////////////////////////
// Create an ItemLog from Item
//////////////////////////////////////////////

func ItemToItemLog(io ItemObject, cdt string) ItemLog {

	iLog := ItemLog{}
	iLog.ItemID = io.ItemID
	iLog.Status = "INITIAL"
	iLog.AuctionedBy = "DEFAULT"
	iLog.RecType = "ILOG"
	iLog.ItemDesc = io.ItemDesc
	iLog.CurrentOwner = io.CurrentOwnerID
	iLog.Date = cdt

	return iLog
}

//////////////////////////////////////////////
// Convert Bid to Transaction for Posting
//////////////////////////////////////////////

func BidtoTransaction(bid Bid) ItemTransaction {

	var t ItemTransaction
	t.AuctionID = bid.AuctionID
	t.RecType = "POSTTRAN"
	t.ItemID = bid.ItemID
	t.TransType = "SALE"
	t.UserId = bid.BuyerID
	// Ideally SystemChain Code must provide a TimeStamp Function
	t.TransDate = bid.BidTime
	t.HammerTime = bid.BidTime
	t.HammerPrice = bid.BidPrice
	t.Details = "The Highest Bidder does not always win"

	return t
}

////////////////////////////////////////////////////////////////////////////
// Validate if the User Information Exists
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func ValidateMember(stub *shim.ChaincodeStub, owner string) ([]byte, error) {

	// Get the Item Objects and Display it
	// Avalbytes, err := stub.GetState(owner)
	args := []string{owner, "USER"}
	Avalbytes, err := itpUtils.QueryLedger(stub, "UserTable", args)

	if err != nil {
		fmt.Println("ValidateMember() : Failed - Cannot find valid owner record for ART  ", owner)
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("ValidateMember() : Failed - Incomplete owner record for ART  ", owner)
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + owner + "\"}"
		return nil, errors.New(jsonResp)
	}

	fmt.Println("ValidateMember() : Validated Item Owner:\n", owner)
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////////////
// Validate if the User Information Exists
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func ValidateItemSubmission(stub *shim.ChaincodeStub, artId string) ([]byte, error) {

	// Get the Item Objects and Display it
	args := []string{artId, "ARTINV"}
	Avalbytes, err := itpUtils.QueryLedger(stub, "ItemTable", args)
	if err != nil {
		fmt.Println("ValidateItemSubmission() : Failed - Cannot find valid owner record for ART  ", artId)
		jsonResp := "{\"Error\":\"Failed to get Owner Object Data for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	if Avalbytes == nil {
		fmt.Println("ValidateItemSubmission() : Failed - Incomplete owner record for ART  ", artId)
		jsonResp := "{\"Error\":\"Failed - Incomplete information about the owner for " + artId + "\"}"
		return nil, errors.New(jsonResp)
	}

	//fmt.Println("ValidateItemSubmission() : Validated Item Owner:", Avalbytes)
	return Avalbytes, nil
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Get List of Bids for an Auction
// in the block-chain --
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetListOfBids", "Args": ["1111"]}'
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetLastBid", "Args": ["1111"]}'
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetHighestBid", "Args": ["1111"]}'
/////////////////////////////////////////////////////////////////////////////////////////////////////
func GetListOfBids(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := itpUtils.GetList(stub, "BidTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfBids operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("BidTable")

	tlist := make([]Bid, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		bid, err := JSONtoBid(ts)
		if err != nil {
			fmt.Println("GetListOfBids() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetListOfBids() operation failed. %s", err)
		}
		tlist[i] = bid
	}

	jsonRows, _ := json.Marshal(tlist)

	fmt.Println("List of Bids Requested : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get List of Auctions that have been initiated
// in the block-chain
// This is a fixed Query to be issued as below
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetListOfInitAucs", "Args": ["2016"]}'
////////////////////////////////////////////////////////////////////////////////////////////////////////
func GetListOfInitAucs(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := itpUtils.GetList(stub, "AucInitTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfInitAucs operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("AucInitTable")

	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		ar, err := JSONtoAucReq(ts)
		if err != nil {
			fmt.Println("GetListOfInitAucs() Failed : Ummarshall error")
			return nil, fmt.Errorf("getBillForMonth() operation failed. %s", err)
		}
		tlist[i] = ar
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Println("List of Auctions Requested : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get List of Open Auctions  for which bids can be supplied
// in the block-chain
// This is a fixed Query to be issued as below
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetListOfOpenAucs", "Args": ["2016"]}'
////////////////////////////////////////////////////////////////////////////
func GetListOfOpenAucs(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	rows, err := itpUtils.GetList(stub, "AucOpenTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetListOfOpenAucs operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("AucOpenTable")

	tlist := make([]AuctionRequest, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		ar, err := JSONtoAucReq(ts)
		if err != nil {
			fmt.Println("GetListOfOpenAucs() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetListOfOpenAucs() operation failed. %s", err)
		}
		tlist[i] = ar
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Println("List of Open Auctions : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get the Item History for an Item
// in the block-chain .. Pass the Item ID
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItemLog", "Args": ["1000"]}'
////////////////////////////////////////////////////////////////////////////
func GetItemLog(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetItemLog(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetItemLog(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetItem\", \"Args\": [\"1111\"]}'")
		return nil, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 12 ")
	}

	rows, err := itpUtils.GetList(stub, "ItemHistoryTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetItemLog() operation failed. Error marshaling JSON: %s", err)
	}
	nCol := GetNumberOfKeys("ItemHistoryTable")

	tlist := make([]ItemLog, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		il, err := JSONtoItemLog(ts)
		if err != nil {
			fmt.Println("() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetItemLog() operation failed. %s", err)
		}
		tlist[i] = il
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Println("All History : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get a List of Items by Category
// in the block-chain
// Input is 2016 + Category
// Categories include whatever has been defined in the Item Tables - Landscape, Modern, ...
// See Sample data
// ./peer chaincode query -l golang -n mycc -c '{"Function": "GetItemListByCat", "Args": ["2016", "Modern"]}'
////////////////////////////////////////////////////////////////////////////
func GetItemListByCat(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetItemListByCat(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetItemListByCat(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetItemListByCat\", \"Args\": [\"Modern\"]}'")
		return nil, errors.New("CreateItemObject(): Incorrect number of arguments. Expecting 1 ")
	}

	rows, err := itpUtils.GetList(stub, "ItemCatTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetItemListByCat() operation failed. Error GetList: %s", err)
	}

	nCol := GetNumberOfKeys("ItemCatTable")

	tlist := make([]ItemObject, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		io, err := JSONtoAR(ts)
		if err != nil {
			fmt.Println("() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetItemListByCat() operation failed. %s", err)
		}
		tlist[i] = io
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Println("All Items : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get a List of Users by Category
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetUserListByCat(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Check there are 1 Arguments provided as per the the struct - two are computed
	// See example
	if len(args) < 1 {
		fmt.Println("GetUserListByCat(): Incorrect number of arguments. Expecting 1 ")
		fmt.Println("GetUserListByCat(): ./peer chaincode query -l golang -n mycc -c '{\"Function\": \"GetUserListByCat\", \"Args\": [\"AH\"]}'")
		return nil, errors.New("CreateUserObject(): Incorrect number of arguments. Expecting 1 ")
	}

	rows, err := itpUtils.GetList(stub, "UserCatTable", args)
	if err != nil {
		return nil, fmt.Errorf("GetUserListByCat() operation failed. Error marshaling JSON: %s", err)
	}

	nCol := GetNumberOfKeys("UserCatTable")

	tlist := make([]UserObject, len(rows))
	for i := 0; i < len(rows); i++ {
		ts := rows[i].Columns[nCol].GetBytes()
		uo, err := JSONtoUser(ts)
		if err != nil {
			fmt.Println("GetUserListByCat() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetUserListByCat() operation failed. %s", err)
		}
		tlist[i] = uo
	}

	jsonRows, _ := json.Marshal(tlist)

	//fmt.Println("All Users : ", jsonRows)
	return jsonRows, nil

}

////////////////////////////////////////////////////////////////////////////
// Get The Highest Bid Received so far for an Auction
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetLastBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := itpUtils.GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nCol := GetNumberOfKeys(tn)
	var Avalbytes []byte
	var dat map[string]interface{}
	layout := "2006-01-02 15:04:05"
	highestTime, err := time.Parse(layout, layout)

	for i := 0; i < len(rows); i++ {
		currentBid := rows[i].Columns[nCol].GetBytes()
		if err := json.Unmarshal(currentBid, &dat); err != nil {
			fmt.Println("GetHighestBid() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetHighestBid(0 operation failed. %s", err)
		}
		bidTime, err := time.Parse(layout, dat["BidTime"].(string))
		if err != nil {
			fmt.Println("GetLastBid() Failed : time Conversion error on BidTime")
			return nil, fmt.Errorf("GetHighestBid() Int Conversion error on BidPrice! failed. %s", err)
		}

		if bidTime.Sub(highestTime) > 0 {
			highestTime = bidTime
			Avalbytes = currentBid
		}
	}

	return Avalbytes, nil

}

////////////////////////////////////////////////////////////////////////////
// Get The Highest Bid Received so far for an Auction
// in the block-chain
////////////////////////////////////////////////////////////////////////////
func GetNoOfBidsReceived(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := itpUtils.GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nBids := len(rows)
	return []byte(strconv.Itoa(nBids)), nil
}

////////////////////////////////////////////////////////////////////////////
// Get the Highest Bid in the List
//
////////////////////////////////////////////////////////////////////////////
func GetHighestBid(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	tn := "BidTable"
	rows, err := itpUtils.GetList(stub, tn, args)
	if err != nil {
		return nil, fmt.Errorf("GetLastBid operation failed. %s", err)
	}
	nCol := GetNumberOfKeys(tn)
	var Avalbytes []byte
	var dat map[string]interface{}
	var bidPrice, highestBid int
	highestBid = 0

	for i := 0; i < len(rows); i++ {
		currentBid := rows[i].Columns[nCol].GetBytes()
		if err := json.Unmarshal(currentBid, &dat); err != nil {
			fmt.Println("GetHighestBid() Failed : Ummarshall error")
			return nil, fmt.Errorf("GetHighestBid(0 operation failed. %s", err)
		}
		bidPrice, err = strconv.Atoi(dat["BidPrice"].(string))
		if err != nil {
			fmt.Println("GetHighestBid() Failed : Int Conversion error on BidPrice")
			return nil, fmt.Errorf("GetHighestBid() Int Conversion error on BidPrice! failed. %s", err)
		}

		if bidPrice >= highestBid {
			highestBid = bidPrice
			Avalbytes = currentBid
		}
	}

	return Avalbytes, nil
}

/////////////////////////////////////////////////////////////////
// This function checks the incoming args stuff for a valid record
// type entry as per the declared array recType[]
// The assumption is that rectType can be anywhere in the args or struct
// not necessarily in args[1] as per my old logic
// The Request type is used to process the record accordingly
/////////////////////////////////////////////////////////////////
func IdentifyReqType(args []string) string {
	for _, rt := range args {
		for _, val := range recType {
			if val == rt {
				return rt
			}
		}
	}
	return "DEFAULT"
}

/////////////////////////////////////////////////////////////////
// This function checks the incoming args stuff for a valid record
// type entry as per the declared array recType[]
// The assumption is that rectType can be anywhere in the args or struct
// not necessarily in args[1] as per my old logic
// The Request type is used to process the record accordingly
/////////////////////////////////////////////////////////////////
func ChkReqType(args []string) bool {
	for _, rt := range args {
		for _, val := range recType {
			if val == rt {
				return true
			}
		}
	}
	return false
}

/////////////////////////////////////////////////////////////////
// Checks if the incoming invoke has a valid requesType
// The Request type is used to process the record accordingly
// Old Logic (see new logic up)
/////////////////////////////////////////////////////////////////
func CheckRequestType(rt string) bool {
	for _, val := range recType {
		if val == rt {
			fmt.Println("CheckRequestType() : Valid Request Type , val : ", val, rt, "\n")
			return true
		}
	}
	fmt.Println("CheckRequestType() : Invalid Request Type , val : ", rt, "\n")
	return false
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Return the right Object Buffer after validation to write to the ledger
// var recType = []string{"ARTINV", "USER", "BID", "AUCREQ", "POSTTRAN", "OPENAUC", "CLAUC"}
/////////////////////////////////////////////////////////////////////////////////////////////

func ProcessQueryResult(stub *shim.ChaincodeStub, Avalbytes []byte, args []string) error {

	// Identify Record Type by scanning the args for one of the recTypes
	// This is kind of a post-processor once the query fetches the results
	// RecType is the style of programming in the punch card days ..
	// ... well

	var dat map[string]interface{}

	if err := json.Unmarshal(Avalbytes, &dat); err != nil {
		panic(err)
	}

	var recType string
	recType = dat["RecType"].(string)
	switch recType {

	case "ARTINV":

		ar, err := JSONtoAR(Avalbytes) //
		if err != nil {
			fmt.Println("ProcessRequestType(): Cannot create itemObject \n")
			return err
		}
		// Decrypt Image and Save Image in a file
		image := itpUtils.Decrypt(ar.AES_Key, ar.ItemImage)
		if err != nil {
			fmt.Println("ProcessRequestType() : Image decrytion failed ")
			return err
		}
		fmt.Println("ProcessRequestType() : Image conversion from byte[] to file successfull ")
		err = itpUtils.ByteArrayToImage(image, ccPath + "copy."+ar.ItemPicFN)
		if err != nil {

			fmt.Println("ProcessRequestType() : Image conversion from byte[] to file failed ")
			return err
		}
		return err

	case "USER":
		ur, err := JSONtoUser(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", ur)
		return err

	case "AUCREQ":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", ar)
		return err
	case "OPENAUC":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", ar)
		return err
	case "CLAUC":
		ar, err := JSONtoAucReq(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", ar)
		return err
	case "POSTTRAN":
		atr, err := JSONtoTran(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", atr)
		return err
	case "BID":
		bid, err := JSONtoBid(Avalbytes) //
		if err != nil {
			return err
		}
		fmt.Println("ProcessRequestType() : ", bid)
		return err
	case "DEFAULT":
		return nil
	case "XFER":
		return nil
	default:

		return errors.New("Unknown")
	}
	return nil

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Trigger the Auction
// Structure of args auctionReqID, RecType, AucStartDateTime, Duration in Minutes ( 3 = 3 minutes)
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "OpenAuctionForBids", "Args":["1111", "OPENAUC", "3", "2006-01-02 15:04:05"]}'
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func OpenAuctionForBids(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Fetch Auction Object and check its Status
	Avalbytes, err := itpUtils.QueryLedger(stub, "AuctionTable", args)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Object Retrieval Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Object Retrieval Failed ")
	}

	aucR, err := JSONtoAucReq(Avalbytes)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Object Unmarshalling Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Object UnMarshalling Failed ")
	}

	if aucR.Status == "CLOSED" {
		fmt.Println("OpenAuctionForBids(): Auction is Closed - Cannot Open for new bids ")
		return nil, errors.New("OpenAuctionForBids(): is Closed - Cannot Open for new bids Failed ")
	}

	// Calculate Time Now and Duration of Auction

	// Validate arg[1]  is an integer as it represents Duration in Minutes
	aucDuration, err := strconv.Atoi(args[2])
	if err != nil {
		fmt.Println("OpenAuctionForBids(): Auction Duration is an integer that represents minute! OpenAuctionForBids() Failed ")
		return nil, errors.New("OpenAuctionForBids(): Auction Duration is an integer that represents minute! OpenAuctionForBids() Failed ")
	}

        aucStartDate, err := time.Parse("2006-01-02 15:04:05", args[3])
	aucEndDate := aucStartDate.Add(time.Duration(aucDuration) * time.Minute)

	// We  don't use go routines anymore to time the auction
	//sleepTime := time.Duration(aucDuration * 60 * 1000 * 1000 * 1000)

	//  Update Auction Object
	aucR.OpenDate = aucStartDate.Format("2006-01-02 15:04:05")
	aucR.CloseDate = aucEndDate.Format("2006-01-02 15:04:05")
	aucR.Status = "OPEN"

	buff, err := UpdateAuctionStatus(stub, "AuctionTable", aucR)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): UpdateAuctionStatus() Failed ")
		return nil, errors.New("OpenAuctionForBids(): UpdateAuctionStatus() Failed ")
	}

	// Remove the Auction from INIT Bucket and move to OPEN bucket
	// This was designed primarily to help the UI

	keys := []string{"2016", aucR.AuctionID}
	err = itpUtils.DeleteFromLedger(stub, "AucInitTable", keys)
	if err != nil {
		fmt.Println("OpenAuctionForBids(): DeleteFromLedger() Failed ")
		return nil, errors.New("OpenAuctionForBids(): DeleteFromLedger() Failed ")
	}

	// Add the Auction to Open Bucket
	err = itpUtils.UpdateLedger(stub, "AucOpenTable", keys, buff)
	if err != nil {
		fmt.Println("OpenAuctionForBids() : write error while inserting record into AucInitTable \n")
		return buff, err
	}

	return buff, err
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a Command to execute Close Auction From the Command line
// cloaseauction.sh is created and then executed as seen below
// The file contains just one line
// /opt/gopath/src/github.com/hyperledger/fabric/peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseAuction", "Args": ["1111","AUCREQ"]}'
// This approach has been used as opposed to exec.Command... because additional logic to gather environment variables etc. is required
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func ShellCmdToCloseAuction(aucID string) error {
	gopath := os.Getenv("GOPATH")
	cdir := fmt.Sprintf("cd %s/src/github.com/hyperledger/fabric/", gopath)
	argStr := "'{\"Function\": \"CloseAuction\", \"Args\": [\"" + aucID + "\"," + "\"AUCREQ\"" + "]}'"
	argStr = fmt.Sprintf("%s/src/github.com/hyperledger/fabric/peer/peer chaincode invoke -l golang -n mycc -c %s", gopath, argStr)

	fileHandle, _ := os.Create(fmt.Sprintf("%s/src/github.com/hyperledger/fabric/peer/closeauction.sh", gopath))
	writer := bufio.NewWriter(fileHandle)
	defer fileHandle.Close()

	fmt.Fprintln(writer, cdir)
	fmt.Fprintln(writer, argStr)
	writer.Flush()

	x := "sh /opt/gopath/src/github.com/hyperledger/fabric/peer/closeauction.sh"
	err := exe_cmd(x)
	if err != nil {
		fmt.Println("%s", err)
	}

	err = exe_cmd("rm /opt/gopath/src/github.com/hyperledger/fabric/peer/closeauction.sh")
	if err != nil {
		fmt.Println("%s", err)
	}

	fmt.Println("Kicking off CloseAuction", argStr)
	return nil
}

func exe_cmd(cmd string) error {

	fmt.Println("command :  ", cmd)
	parts := strings.Fields(cmd)
	head := parts[0]
	parts = parts[1:len(parts)]

	_, err := exec.Command(head, parts...).CombinedOutput()
	if err != nil {
		fmt.Println("%s", err)
	}
	return err
}

//////////////////////////////////////////////////////////////////////////
// Close Open Auctions
// 1. Read OpenAucTable
// 2. Compare now with expiry time with now 
// 3. If now is > expiry time call CloseAuction
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseOpenAuctions", "Args": ["2016", "CLAUC", currentDateTime]}'
//////////////////////////////////////////////////////////////////////////

func CloseOpenAuctions(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

        rows, err := GetListOfOpenAucs(stub, "AucOpenTable", []string{"2016"})
        if err != nil {
                return nil, fmt.Errorf("GetListOfOpenAucs operation failed. Error marshaling JSON: %s", err)
        }

        tlist := make([]AuctionRequest, len(rows))
	err = json.Unmarshal([]byte(rows), &tlist)
	if err != nil {
		fmt.Println("Unmarshal failed : ", err)
	}

        for i := 0; i < len(tlist); i++ {
                ar := tlist[i]
                if err != nil {
                        fmt.Println("CloseOpenAuctions() Failed : Ummarshall error")
                        return nil, fmt.Errorf("GetListOfOpenAucs() operation failed. %s", err)
                }

                fmt.Println("CloseOpenAuctions() ", ar)

		// Compare Auction Times where args[2] = the CurrentTime sent by the client
        	if tCompare(args[2], ar.CloseDate) == false {

                	// Request Closing Auction
                	_, err := CloseAuction(stub,"CloseAuction", []string{ar.AuctionID})
                	if err != nil {
                       		 fmt.Println("CloseOpenAuctions() Failed : Ummarshall error")
                       		 return nil, fmt.Errorf("GetListOfOpenAucs() operation failed. %s", err)
                	}
		}
        }

        return rows, nil
}

//////////////////////////////////////////////////////////////////////////
// Close the Auction
// This is invoked by OpenAuctionForBids
// which kicks-off a go-routine timer for the duration of the auction
// When the timer expires, it creates a shell script to CloseAuction() and triggers it
// This function can also be invoked via CLI - the intent was to close as and when I implement BuyItNow()
// CloseAuction
// - Sets the status of the Auction to "CLOSED"
// - Removes the Auction from the Open Auction list (AucOpenTable)
// - Retrieves the Highest Bid and creates a Transaction
// - Posts The Transaction
//
// To invoke from Command Line via CLI or REST API
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseAuction", "Args": ["1111", "AUCREQ"]}'
// ./peer chaincode invoke -l golang -n mycc -c '{"Function": "CloseAuction", "Args": ["1111", "AUCREQ"]}'
//
//////////////////////////////////////////////////////////////////////////

func CloseAuction(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Close The Auction -  Fetch Auction Object
	Avalbytes, err := itpUtils.QueryLedger(stub, "AuctionTable", []string{args[0], "AUCREQ"})
	if err != nil {
		fmt.Println("CloseAuction(): Auction Object Retrieval Failed ")
		return nil, errors.New("CloseAuction(): Auction Object Retrieval Failed ")
	}

	aucR, err := JSONtoAucReq(Avalbytes)
	if err != nil {
		fmt.Println("CloseAuction(): Auction Object Unmarshalling Failed ")
		return nil, errors.New("CloseAuction(): Auction Object UnMarshalling Failed ")
	}

	//  Update Auction Status
	aucR.Status = "CLOSED"
	fmt.Println("CloseAuction(): UpdateAuctionStatus() successful ", aucR)

	Avalbytes, err = UpdateAuctionStatus(stub, "AuctionTable", aucR)
	if err != nil {
		fmt.Println("CloseAuction(): UpdateAuctionStatus() Failed ")
		return nil, errors.New("CloseAuction(): UpdateAuctionStatus() Failed ")
	}

	// Remove the Auction from Open Bucket
	keys := []string{"2016", aucR.AuctionID}
	err = itpUtils.DeleteFromLedger(stub, "AucOpenTable", keys)
	if err != nil {
		fmt.Println("CloseAuction(): DeleteFromLedger(AucOpenTable) Failed ")
		return nil, errors.New("CloseAuction(): DeleteFromLedger(AucOpenTable) Failed ")
	}

	fmt.Println("CloseAuction(): Proceeding to process the highest bid ")

	// Process Final Bid - Turn it into a Transaction
	Avalbytes, err = GetHighestBid(stub, "GetHighestBid", []string{args[0]})
        if Avalbytes == nil {
                fmt.Println("CloseAuction(): No bids available, no change in Item Status - PostTransaction() Completed Successfully ")
        	return Avalbytes, nil
	}

        if err != nil {
                fmt.Println("CloseAuction(): No bids available, error encountered - PostTransaction() failed ")
                return nil, err
        }

	bid, _ := JSONtoBid(Avalbytes)
	fmt.Println("CloseAuction(): Proceeding to process the highest bid ", bid)
	tran := BidtoTransaction(bid)
	fmt.Println("CloseAuction(): Converting Bid to tran ", tran)

	// Process the last bid once Time Expires
	tranArgs := []string{tran.AuctionID, tran.RecType, tran.ItemID, tran.TransType, tran.UserId, tran.TransDate, tran.HammerTime, tran.HammerPrice, tran.Details}
	fmt.Println("CloseAuction(): Proceeding to process the  Transaction ", tranArgs)

	Avalbytes, err = PostTransaction(stub, "PostTransaction", tranArgs)
	if err != nil {
		fmt.Println("CloseAuction(): PostTransaction() Failed ")
		return nil, errors.New("CloseAuction(): PostTransaction() Failed ")
	}
	fmt.Println("CloseAuction(): PostTransaction() Completed Successfully ")
	return Avalbytes, nil
}

////////////////////////////////////////////////////////////////////////////////////////////
// Buy It Now
// Rules:
// If Buy IT Now Option is available then a Buyer has the option to buy the ITEM
// before the bids exceed BuyITNow Price . Normally, The application should take of this
// at the UI level and this chain-code assumes application has validated that
////////////////////////////////////////////////////////////////////////////////////////////

func BuyItNow(stub *shim.ChaincodeStub, function string, args []string) ([]byte, error) {

	// Process Final Bid - Turn it into a Transaction
	Avalbytes, err := GetHighestBid(stub, "GetHighestBid", []string{args[0]})
	bid, err := JSONtoBid(Avalbytes)
	if err != nil {
		return nil, errors.New("BuyItNow() : JSONtoBid Error")
	}

	// Check if BuyItNow Price > Highest Bid so far
	binP, err := strconv.Atoi(args[5])
	if err != nil {
		return nil, errors.New("BuyItNow() : Invalid BuyItNow Price")
	}

	hbP, err := strconv.Atoi(bid.BidPrice)
	if err != nil {
		return nil, errors.New("BuyItNow() : Invalid Highest Bid Price")
	}

	if hbP > binP {
		return nil, errors.New("BuyItNow() : Highest Bid Price > BuyItNow Price - BuyItNow Rejected")
	}

	// Close The Auction -  Fetch Auction Object
	Avalbytes, err = itpUtils.QueryLedger(stub, "AuctionTable", []string{args[0], "AUCREQ"})
	if err != nil {
		fmt.Println("BuyItNow(): Auction Object Retrieval Failed ")
		return nil, errors.New("BuyItNow(): Auction Object Retrieval Failed ")
	}

	aucR, err := JSONtoAucReq(Avalbytes)
	if err != nil {
		fmt.Println("BuyItNow(): Auction Object Unmarshalling Failed ")
		return nil, errors.New("BuyItNow(): Auction Object UnMarshalling Failed ")
	}

	//  Update Auction Status
	aucR.Status = "CLOSED"
	fmt.Println("BuyItNow(): UpdateAuctionStatus() successful ", aucR)

	Avalbytes, err = UpdateAuctionStatus(stub, "AuctionTable", aucR)
	if err != nil {
		fmt.Println("BuyItNow(): UpdateAuctionStatus() Failed ")
		return nil, errors.New("BuyItNow(): UpdateAuctionStatus() Failed ")
	}

	// Remove the Auction from Open Bucket
	keys := []string{"2016", aucR.AuctionID}
	err = itpUtils.DeleteFromLedger(stub, "AucOpenTable", keys)
	if err != nil {
		fmt.Println("BuyItNow(): DeleteFromLedger(AucOpenTable) Failed ")
		return nil, errors.New("BuyItNow(): DeleteFromLedger(AucOpenTable) Failed ")
	}

	fmt.Println("BuyItNow(): Proceeding to process the highest bid ")

	// Convert the BuyITNow to a Bid type struct
	buyItNowBid, err := CreateBidObject(args[0:])
	if err != nil {
		return nil, err
	}

	// Reject the offer if the Buyer Information Is not Valid or not registered on the Block Chain
	buyerInfo, err := ValidateMember(stub, args[4])
	fmt.Println("Buyer information  ", buyerInfo, args[4])
	if err != nil {
		fmt.Println("BuyItNow() : Failed Buyer not registered on the block-chain ", args[4])
		return nil, err
	}

	tran := BidtoTransaction(buyItNowBid)
	fmt.Println("BuyItNow(): Converting Bid to tran ", tran)

	// Process the buy-it-now offer
	tranArgs := []string{tran.AuctionID, tran.RecType, tran.ItemID, tran.TransType, tran.UserId, tran.TransDate, tran.HammerTime, tran.HammerPrice, tran.Details}
	fmt.Println("BuyItNow(): Proceeding to process the  Transaction ", tranArgs)

	Avalbytes, err = PostTransaction(stub, "PostTransaction", tranArgs)
	if err != nil {
		fmt.Println("BuyItNow(): PostTransaction() Failed ")
		return nil, errors.New("CloseAuction(): PostTransaction() Failed ")
	}
	fmt.Println("BuyItNow(): PostTransaction() Completed Successfully ")
	return Avalbytes, nil
}

//////////////////////////////////////////////////////////////////////////
// Update the Auction Object
// This function updates the status of the auction
// from INIT to OPEN to CLOSED
//////////////////////////////////////////////////////////////////////////

func UpdateAuctionStatus(stub *shim.ChaincodeStub, tableName string, ar AuctionRequest) ([]byte, error) {

	buff, err := AucReqtoJSON(ar)
	if err != nil {
		fmt.Println("UpdateAuctionStatus() : Failed Cannot create object buffer for write : ", ar.AuctionID)
		return nil, errors.New("UpdateAuctionStatus(): Failed Cannot create object buffer for write : " + ar.AuctionID)
	}

	// Update the ledger with the Buffer Data
	keys := []string{ar.AuctionID, ar.ItemID}
	err = itpUtils.ReplaceLedgerEntry(stub, "AuctionTable", keys, buff)
	if err != nil {
		fmt.Println("UpdateAuctionStatus() : write error while inserting record\n")
		return buff, err
	}
	return buff, err
}
